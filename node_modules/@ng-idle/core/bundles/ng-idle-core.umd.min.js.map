{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../projects/core/src/lib/idleexpiry.ts","../../../projects/core/src/lib/interrupt.ts","../../../projects/core/src/lib/keepalivesvc.ts","../../../projects/core/src/lib/alternativestorage.ts","../../../projects/core/src/lib/localstorage.ts","../../../projects/core/src/lib/idle.ts","../../../projects/core/src/lib/localstorageexpiry.ts","../../../projects/core/src/lib/interruptargs.ts","../../../projects/core/src/lib/interruptsource.ts","../../../projects/core/src/lib/eventtargetinterruptsource.ts","../../../projects/core/src/lib/documentinterruptsource.ts","../../../projects/core/src/lib/windowinterruptsource.ts","../../../projects/core/src/lib/storageinterruptsource.ts","../../../projects/core/src/lib/simpleexpiry.ts","../../../projects/core/src/lib/module.ts","../../../projects/core/src/lib/defaultinterruptsources.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","this","constructor","create","__values","o","s","Symbol","iterator","m","i","length","next","value","done","TypeError","__read","n","r","e","ar","push","error","IdleExpiry","idValue","Date","idlingValue","id","Error","idling","now","isExpired","expiry","last","Interrupt","source","subscribe","fn","sub","onInterrupt","unsubscribe","resume","attach","pause","detach","AlternativeStorage","storageMap","defineProperty","keys","clear","getItem","key","index","removeItem","undefined","setItem","LocalStorage","storage","getStorage","localStorage","err","data","_wrapped","Injectable","AutoResume","LocalStorageExpiry","_this","_super","idleName","setExpiry","getExpiry","setIdling","getIdling","getIdleName","setIdleName","parseInt","getTime","toString","Idle","zone","keepaliveSvc","idle","timeoutVal","autoResume","interrupts","running","keepaliveEnabled","onIdleStart","EventEmitter","onIdleEnd","onTimeoutWarning","onTimeout","getKeepaliveEnabled","setKeepaliveEnabled","getTimeout","setTimeout","seconds","getIdle","setIdle","getAutoResume","setAutoResume","setInterrupts","sources","clearInterrupts","self","sources_1","sources_1_1","args","interrupt","force","innerArgs","getInterrupts","_b","_c","isRunning","isIdling","watch","skipExpiry","safeClearInterval","timeout","toggleState","startKeepalive","toggleInterrupts","watchFn","run","diff","getExpiryDiff","setIdleIntervalOutsideOfZone","frequency","runOutsideAngular","idleHandle","setInterval","stop","stopKeepalive","countdown","emit","eventArgs","notIdle","doCountdown","setTimoutIntervalOutsideZone","doCountdownInZone","intervalFn","timeoutHandle","handleName","handle","clearInterval","ping","start","ngOnDestroy","NgZone","KeepaliveSvc","decorators","type","Optional","InterruptSource","attachFn","detachFn","isAttached","Zone","current","get","parent","EventTargetInterruptSource","target","events","options","eventSubscription","Subscription","throttleDelay","passive","opts","fromEvents","split","map","eventName","fromEvent","eventSrc","merge","apply","arguments","concat","__spread","pipe","filter","filterEvent","throttleTime","handler","InterruptArgs","event","DocumentInterruptSource","document","documentElement","originalEvent","movementX","movementY","WindowInterruptSource","window","StorageInterruptSource","indexOf","SimpleExpiry","lastValue","NgIdleModule","forRoot","ngModule","providers","provide","useExisting","createDefaultInterruptSources","NgModule","DEFAULT_INTERRUPTSOURCES"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/*\n * Represents a base class for types that provide expiry detection for the Idle service.\n */\nexport abstract class IdleExpiry {\n  protected idValue: any;\n  protected idlingValue: boolean;\n\n  constructor() {\n    this.idValue = new Date();\n    this.idlingValue = false;\n  }\n\n  /*\n   * Gets or sets a unique ID for the window\n   * @param id - The id.\n   * @return The current id.\n   */\n  id(value?: any): any {\n    if (value !== void 0) {\n      if (!value) {\n        throw new Error('A value must be specified for the ID.');\n      }\n\n      this.idValue = value;\n    }\n\n    return this.idValue;\n  }\n\n  /*\n   * Gets or sets the last expiry date.\n   * @param value - The value to set.\n   * @return The last expiry value.\n   */\n  abstract last(value?: Date): Date;\n\n  /*\n   * Gets or sets the idling value.\n   * @param value - The value to set.\n   * @return The idling value.\n   */\n  idling(value?: boolean): boolean {\n    if (value !== void 0) {\n      this.idlingValue = value;\n    }\n\n    return this.idlingValue;\n  }\n\n  /*\n   * Returns the current Date.\n   * @return The current Date.\n   */\n  now(): Date {\n    /* istanbul ignore next */\n    return new Date();\n  }\n\n  /*\n   * Returns whether or not it is expired.\n   * @return True if expired; otherwise, false.\n   */\n  isExpired(): boolean {\n    const expiry = this.last();\n    return expiry != null && expiry <= this.now();\n  }\n}\n","import { Subscription } from 'rxjs';\n\nimport { InterruptArgs } from './interruptargs';\nimport { InterruptSource } from './interruptsource';\n\n/*\n * A class for managing an interrupt from an interrupt source.\n */\nexport class Interrupt {\n  private sub: Subscription;\n\n  constructor(public source: InterruptSource) {}\n\n  /*\n   * Subscribes to the interrupt using the specified function.\n   * @param fn - The subscription function.\n   */\n  subscribe(fn: (args: InterruptArgs) => void): void {\n    this.sub = this.source.onInterrupt.subscribe(fn);\n  }\n\n  /*\n   * Unsubscribes the interrupt.\n   */\n  unsubscribe(): void {\n    this.sub.unsubscribe();\n    this.sub = null;\n  }\n\n  /*\n   * Keeps the subscription but resumes interrupt events.\n   */\n  resume(): void {\n    this.source.attach();\n  }\n\n  /*\n   * Keeps the subscription but pauses interrupt events.\n   */\n  pause(): void {\n    this.source.detach();\n  }\n}\n","export abstract class KeepaliveSvc {\n  abstract start(): void;\n  abstract stop(): void;\n  abstract ping(): void;\n}\n","/*\n * Represents an alternative storage for browser that doesn't support localstorage. (i.e. Safari in\n * private mode)\n * @implements Storage\n */\nexport class AlternativeStorage implements Storage {\n  private storageMap: any = {};\n\n  /*\n   * Returns an integer representing the number of data items stored in the storageMap object.\n   */\n  get length() {\n    return Object.keys(this.storageMap).length;\n  }\n\n  /*\n   * Remove all keys out of the storage.\n   */\n  clear(): void {\n    this.storageMap = {};\n  }\n\n  /*\n   * Return the key's value\n   *\n   * @param key - name of the key to retrieve the value of.\n   * @return The key's value\n   */\n  getItem(key: string): string | null {\n    if (typeof this.storageMap[key] !== 'undefined') {\n      return this.storageMap[key];\n    }\n    return null;\n  }\n\n  /*\n   * Return the nth key in the storage\n   *\n   * @param index - the number of the key you want to get the name of.\n   * @return The name of the key.\n   */\n  key(index: number): string | null {\n    return Object.keys(this.storageMap)[index] || null;\n  }\n\n  /*\n   * Remove a key from the storage.\n   *\n   * @param key - the name of the key you want to remove.\n   */\n  removeItem(key: string): void {\n    this.storageMap[key] = undefined;\n  }\n\n  /*\n   * Add a key to the storage, or update a key's value if it already exists.\n   *\n   * @param key - the name of the key.\n   * @param value - the value you want to give to the key.\n   */\n  setItem(key: string, value: string): void {\n    this.storageMap[key] = value;\n  }\n\n  [key: string]: any;\n  [index: number]: string;\n}\n","import { Injectable } from '@angular/core';\nimport { AlternativeStorage } from './alternativestorage';\n\n/*\n * Represents a localStorage store.\n */\n@Injectable()\nexport class LocalStorage {\n  private storage: Storage;\n\n  constructor() {\n    this.storage = this.getStorage();\n  }\n\n  /*\n   * Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem\n   * throw QuotaExceededError. We're going to detect this and just silently drop any calls to\n   * setItem\n   * to avoid the entire page breaking, without having to do a check at each usage of Storage.\n   */\n  private getStorage(): Storage {\n    try {\n      const storage = localStorage;\n      storage.setItem('ng2IdleStorage', '');\n      storage.removeItem('ng2IdleStorage');\n      return storage;\n    } catch (err) {\n      return new AlternativeStorage();\n    }\n  }\n\n  /*\n   * Gets an item in the storage.\n   *\n   * @param value - The value to get.\n   * @return The current value.\n   */\n  getItem(key: string): string | null {\n    return this.storage.getItem('ng2Idle.' + key);\n  }\n\n  /*\n   * Removes an item in the storage.\n   *\n   * @param value - The value to remove.\n   */\n  removeItem(key: string): void {\n    this.storage.removeItem('ng2Idle.' + key);\n  }\n\n  /*\n   * Sets an item in the storage.\n   *\n   * @param key - The key to set the value.\n   * @param value - The value to set to the key.\n   */\n  setItem(key: string, data: string): void {\n    this.storage.setItem('ng2Idle.' + key, data);\n  }\n\n  /*\n   * Represents the storage, commonly use for testing purposes.\n   *\n   * @param key - The key to set the value.\n   * @param value - The value to set to the key.\n   */\n  _wrapped(): Storage {\n    return this.storage;\n  }\n}\n","import {\n  EventEmitter,\n  Injectable,\n  NgZone,\n  OnDestroy,\n  Optional\n} from '@angular/core';\n\nimport { IdleExpiry } from './idleexpiry';\nimport { Interrupt } from './interrupt';\nimport { InterruptArgs } from './interruptargs';\nimport { InterruptSource } from './interruptsource';\nimport { KeepaliveSvc } from './keepalivesvc';\nimport { LocalStorageExpiry } from './localstorageexpiry';\n\n/*\n * Indicates the desired auto resume behavior.\n */\nexport enum AutoResume {\n  /*\n   * Auto resume functionality will be disabled.\n   */\n  disabled,\n  /*\n   * Can resume automatically even if they are idle.\n   */\n  idle,\n  /*\n   * Can only resume automatically if they are not yet idle.\n   */\n  notIdle\n}\n\n/**\n * A service for detecting and responding to user idleness.\n */\n@Injectable()\nexport class Idle implements OnDestroy {\n  private idle: number = 20 * 60; // in seconds\n  private timeoutVal = 30; // in seconds\n  private autoResume: AutoResume = AutoResume.idle;\n  private interrupts: Array<Interrupt> = new Array();\n  private running = false;\n  private idling: boolean;\n  private idleHandle: any;\n  private timeoutHandle: any;\n  private countdown: number;\n  private keepaliveEnabled = false;\n  private keepaliveSvc: KeepaliveSvc;\n\n  public onIdleStart: EventEmitter<any> = new EventEmitter();\n  public onIdleEnd: EventEmitter<any> = new EventEmitter();\n  public onTimeoutWarning: EventEmitter<number> = new EventEmitter<number>();\n  public onTimeout: EventEmitter<number> = new EventEmitter<number>();\n  public onInterrupt: EventEmitter<any> = new EventEmitter();\n\n  [key: string]: any;\n\n  constructor(\n    private expiry: IdleExpiry,\n    private zone: NgZone,\n    @Optional() keepaliveSvc?: KeepaliveSvc\n  ) {\n    if (keepaliveSvc) {\n      this.keepaliveSvc = keepaliveSvc;\n      this.keepaliveEnabled = true;\n    }\n    this.setIdling(false);\n  }\n\n  /*\n   * Sets the idle name for localStorage.\n   * Important to set if multiple instances of Idle with LocalStorageExpiry\n   * @param The name of the idle.\n   */\n  setIdleName(key: string): void {\n    if (this.expiry instanceof LocalStorageExpiry) {\n      this.expiry.setIdleName(key);\n    } else {\n      throw new Error(\n        'Cannot set expiry key name because no LocalStorageExpiry has been provided.'\n      );\n    }\n  }\n\n  /*\n   * Returns whether or not keepalive integration is enabled.\n   * @return True if integration is enabled; otherwise, false.\n   */\n  getKeepaliveEnabled(): boolean {\n    return this.keepaliveEnabled;\n  }\n\n  /*\n   * Sets and returns whether or not keepalive integration is enabled.\n   * @param True if the integration is enabled; otherwise, false.\n   * @return The current value.\n   */\n  setKeepaliveEnabled(value: boolean): boolean {\n    if (!this.keepaliveSvc) {\n      throw new Error(\n        'Cannot enable keepalive integration because no KeepaliveSvc has been provided.'\n      );\n    }\n\n    return (this.keepaliveEnabled = value);\n  }\n\n  /*\n   * Returns the current timeout value.\n   * @return The timeout value in seconds.\n   */\n  getTimeout(): number {\n    return this.timeoutVal;\n  }\n\n  /*\n   * Sets the timeout value.\n   * @param seconds - The timeout value in seconds. 0 or false to disable timeout feature.\n   * @return The current value. If disabled, the value will be 0.\n   */\n  setTimeout(seconds: number | boolean): number {\n    if (seconds === false) {\n      this.timeoutVal = 0;\n    } else if (typeof seconds === 'number' && seconds >= 0) {\n      this.timeoutVal = seconds;\n    } else {\n      throw new Error(\"'seconds' can only be 'false' or a positive number.\");\n    }\n\n    return this.timeoutVal;\n  }\n\n  /*\n   * Returns the current idle value.\n   * @return The idle value in seconds.\n   */\n  getIdle(): number {\n    return this.idle;\n  }\n\n  /*\n   * Sets the idle value.\n   * @param seconds - The idle value in seconds.\n   * @return The idle value in seconds.\n   */\n  setIdle(seconds: number): number {\n    if (seconds <= 0) {\n      throw new Error(\"'seconds' must be greater zero\");\n    }\n\n    return (this.idle = seconds);\n  }\n\n  /*\n   * Returns the current autoresume value.\n   * @return The current value.\n   */\n  getAutoResume(): AutoResume {\n    return this.autoResume;\n  }\n\n  setAutoResume(value: AutoResume): AutoResume {\n    return (this.autoResume = value);\n  }\n\n  /*\n   * Sets interrupts from the specified sources.\n   * @param sources - Interrupt sources.\n   * @return The resulting interrupts.\n   */\n  setInterrupts(sources: Array<InterruptSource>): Array<Interrupt> {\n    this.clearInterrupts();\n\n    const self = this;\n\n    for (const source of sources) {\n      const sub = new Interrupt(source);\n      sub.subscribe((args: InterruptArgs) => {\n        self.interrupt(args.force, args.innerArgs);\n      });\n\n      this.interrupts.push(sub);\n    }\n\n    return this.interrupts;\n  }\n\n  /*\n   * Returns the current interrupts.\n   * @return The current interrupts.\n   */\n  getInterrupts(): Array<Interrupt> {\n    return this.interrupts;\n  }\n\n  /*\n   * Pauses, unsubscribes, and clears the current interrupt subscriptions.\n   */\n  clearInterrupts(): void {\n    for (const sub of this.interrupts) {\n      sub.pause();\n      sub.unsubscribe();\n    }\n\n    this.interrupts.length = 0;\n  }\n\n  /*\n   * Returns whether or not the service is running i.e. watching for idleness.\n   * @return True if service is watching; otherwise, false.\n   */\n  isRunning(): boolean {\n    return this.running;\n  }\n\n  /*\n   * Returns whether or not the user is considered idle.\n   * @return True if the user is in the idle state; otherwise, false.\n   */\n  isIdling(): boolean {\n    return this.idling;\n  }\n\n  /*\n   * Starts watching for inactivity.\n   */\n  watch(skipExpiry?: boolean): void {\n    this.safeClearInterval('idleHandle');\n    this.safeClearInterval('timeoutHandle');\n\n    const timeout = !this.timeoutVal ? 0 : this.timeoutVal;\n    if (!skipExpiry) {\n      const value = new Date(\n        this.expiry.now().getTime() + (this.idle + timeout) * 1000\n      );\n      this.expiry.last(value);\n    }\n\n    if (this.idling) {\n      this.toggleState();\n    }\n    if (!this.running) {\n      this.startKeepalive();\n      this.toggleInterrupts(true);\n    }\n\n    this.running = true;\n\n    const watchFn = () => {\n      this.zone.run(() => {\n        const diff = this.getExpiryDiff(timeout);\n        if (diff > 0) {\n          this.safeClearInterval('idleHandle');\n          this.setIdleIntervalOutsideOfZone(watchFn, diff);\n        } else {\n          this.toggleState();\n        }\n      });\n    };\n\n    this.setIdleIntervalOutsideOfZone(watchFn, this.idle * 1000);\n  }\n\n  /*\n   * Allows protractor tests to call waitForAngular without hanging\n   */\n  setIdleIntervalOutsideOfZone(watchFn: () => void, frequency: number): void {\n    this.zone.runOutsideAngular(() => {\n      this.idleHandle = setInterval(watchFn, frequency);\n    });\n  }\n\n  /*\n   * Stops watching for inactivity.\n   */\n  stop(): void {\n    this.stopKeepalive();\n\n    this.toggleInterrupts(false);\n\n    this.safeClearInterval('idleHandle');\n    this.safeClearInterval('timeoutHandle');\n\n    this.setIdling(false);\n    this.running = false;\n\n    this.expiry.last(null);\n  }\n\n  /*\n   * Forces a timeout event and state.\n   */\n  timeout(): void {\n    this.stopKeepalive();\n\n    this.toggleInterrupts(false);\n\n    this.safeClearInterval('idleHandle');\n    this.safeClearInterval('timeoutHandle');\n\n    this.setIdling(true);\n    this.running = false;\n    this.countdown = 0;\n\n    this.onTimeout.emit(null);\n  }\n\n  /*\n   * Signals that user activity has occurred.\n   * @param force - Forces watch to be called, unless they are timed out.\n   * @param eventArgs - Optional source event arguments.\n   */\n  interrupt(force?: boolean, eventArgs?: any): void {\n    if (!this.running) {\n      return;\n    }\n\n    if (this.timeoutVal && this.expiry.isExpired()) {\n      this.timeout();\n      return;\n    }\n    this.onInterrupt.emit(eventArgs);\n\n    if (\n      force === true ||\n      this.autoResume === AutoResume.idle ||\n      (this.autoResume === AutoResume.notIdle && !this.expiry.idling())\n    ) {\n      this.watch(force);\n    }\n  }\n\n  private setIdling(value: boolean): void {\n    this.idling = value;\n    this.expiry.idling(value);\n  }\n\n  private toggleState(): void {\n    this.setIdling(!this.idling);\n\n    if (this.idling) {\n      this.onIdleStart.emit(null);\n      this.stopKeepalive();\n\n      if (this.timeoutVal > 0) {\n        this.countdown = this.timeoutVal;\n        this.doCountdown();\n        this.setTimoutIntervalOutsideZone(() => {\n          this.doCountdownInZone();\n        }, 1000);\n      }\n    } else {\n      this.toggleInterrupts(true);\n      this.onIdleEnd.emit(null);\n      this.startKeepalive();\n    }\n\n    this.safeClearInterval('idleHandle');\n  }\n\n  private setTimoutIntervalOutsideZone(\n    intervalFn: () => void,\n    frequency: number\n  ) {\n    this.zone.runOutsideAngular(() => {\n      this.timeoutHandle = setInterval(() => {\n        intervalFn();\n      }, frequency);\n    });\n  }\n\n  private toggleInterrupts(resume: boolean): void {\n    for (const interrupt of this.interrupts) {\n      if (resume) {\n        interrupt.resume();\n      } else {\n        interrupt.pause();\n      }\n    }\n  }\n\n  private getExpiryDiff(timeout: number): number {\n    const now: Date = this.expiry.now();\n    const last: Date = this.expiry.last() || now;\n    return last.getTime() - now.getTime() - timeout * 1000;\n  }\n\n  private doCountdownInZone(): void {\n    this.zone.run(() => {\n      this.doCountdown();\n    });\n  }\n\n  private doCountdown(): void {\n    const diff = this.getExpiryDiff(this.timeoutVal);\n    if (diff > 0) {\n      this.safeClearInterval('timeoutHandle');\n      this.interrupt(true);\n      return;\n    }\n\n    if (!this.idling) {\n      return;\n    }\n\n    if (this.countdown <= 0) {\n      this.timeout();\n      return;\n    }\n\n    this.onTimeoutWarning.emit(this.countdown);\n    this.countdown--;\n  }\n\n  private safeClearInterval(handleName: string): void {\n    const handle = this[handleName];\n    if (handle !== null && typeof handle !== 'undefined') {\n      clearInterval(this[handleName]);\n      this[handleName] = null;\n    }\n  }\n\n  private startKeepalive(): void {\n    if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n      return;\n    }\n\n    if (this.running) {\n      this.keepaliveSvc.ping();\n    }\n\n    this.keepaliveSvc.start();\n  }\n\n  private stopKeepalive(): void {\n    if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n      return;\n    }\n\n    this.keepaliveSvc.stop();\n  }\n\n  /*\n   * Called by Angular when destroying the instance.\n   */\n  ngOnDestroy(): void {\n    this.stop();\n    this.clearInterrupts();\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { IdleExpiry } from './idleexpiry';\nimport { LocalStorage } from './localstorage';\n\n/*\n * Represents a localStorage store of expiry values.\n * @extends IdleExpiry\n */\n@Injectable()\nexport class LocalStorageExpiry extends IdleExpiry {\n  private idleName = 'main';\n\n  constructor(private localStorage: LocalStorage) {\n    super();\n  }\n\n  /*\n   * Gets or sets the last expiry date in localStorage.\n   * If localStorage doesn't work correctly (i.e. Safari in private mode), we store the expiry value in memory.\n   * @param value - The expiry value to set; omit to only return the value.\n   * @return The current expiry value.\n   */\n  last(value?: Date): Date {\n    if (value !== void 0) {\n      this.setExpiry(value);\n    }\n    return this.getExpiry();\n  }\n\n  idling(value?: boolean): boolean {\n    if (value !== void 0) {\n      this.setIdling(value);\n    }\n    return this.getIdling();\n  }\n\n  /*\n   * Gets the idle name.\n   * @return The name of the idle.\n   */\n  getIdleName(): string {\n    return this.idleName;\n  }\n\n  /*\n   * Sets the idle name.\n   * @param The name of the idle.\n   */\n  setIdleName(key: string): void {\n    if (key) {\n      this.idleName = key;\n    }\n  }\n\n  private getExpiry(): Date {\n    const expiry: string = this.localStorage.getItem(this.idleName + '.expiry');\n    if (expiry) {\n      return new Date(parseInt(expiry, 10));\n    } else {\n      return null;\n    }\n  }\n\n  private setExpiry(value: Date) {\n    if (value) {\n      this.localStorage.setItem(\n        this.idleName + '.expiry',\n        value.getTime().toString()\n      );\n    } else {\n      this.localStorage.removeItem(this.idleName + '.expiry');\n    }\n  }\n\n  private getIdling(): boolean {\n    const idling: string = this.localStorage.getItem(this.idleName + '.idling');\n    if (idling) {\n      return idling === 'true';\n    } else {\n      return false;\n    }\n  }\n\n  private setIdling(value: boolean) {\n    if (value) {\n      this.localStorage.setItem(this.idleName + '.idling', value.toString());\n    } else {\n      this.localStorage.setItem(this.idleName + '.idling', 'false');\n    }\n  }\n}\n","import { InterruptSource } from './interruptsource';\n\n/*\n * A class for expressing arguments to interrupt events.\n */\nexport class InterruptArgs {\n  constructor(\n    public source: InterruptSource,\n    public innerArgs: any,\n    public force = false\n  ) {}\n}\n","import { EventEmitter } from '@angular/core';\n\nimport { InterruptArgs } from './interruptargs';\n\ndeclare const Zone: any;\n\n/*\n * A base for classes that act as a source for interrupts.\n */\nexport abstract class InterruptSource {\n  isAttached = false;\n\n  public onInterrupt: EventEmitter<InterruptArgs> = new EventEmitter<\n    InterruptArgs\n  >();\n\n  constructor(\n    protected attachFn?: (source: InterruptSource) => void,\n    protected detachFn?: (source: InterruptSource) => void\n  ) {}\n\n  /*\n   * Attaches to the specified events on the specified source.\n   */\n  attach(): void {\n    // If the current zone is the 'angular' zone (a.k.a. NgZone) then re-enter this method in its parent zone\n    // The parent zone is usually the '<root>' zone but it can also be 'long-stack-trace-zone' in debug mode\n    // In tests, the current zone is typically a 'ProxyZone' created by async/fakeAsync (from @angular/core/testing)\n    if (Zone.current.get('isAngularZone') === true) {\n      Zone.current.parent.run(() => this.attach());\n      return;\n    }\n\n    if (!this.isAttached && this.attachFn) {\n      this.attachFn(this);\n    }\n\n    this.isAttached = true;\n  }\n\n  /*\n   * Detaches from the specified events on the specified source.\n   */\n  detach(): void {\n    if (this.isAttached && this.detachFn) {\n      this.detachFn(this);\n    }\n\n    this.isAttached = false;\n  }\n}\n","import { Observable, Subscription, fromEvent, merge } from 'rxjs';\nimport { filter, throttleTime } from 'rxjs/operators';\n\nimport { InterruptArgs } from './interruptargs';\nimport { InterruptSource } from './interruptsource';\n\n/**\n * Options for EventTargetInterruptSource\n */\nexport interface EventTargetInterruptOptions {\n  /**\n   * The number of milliseconds to throttle the events coming from the target.\n   */\n  throttleDelay?: number;\n\n  /**\n   * Whether or not to use passive event listeners.\n   * Note: you need to detect if the browser supports passive listeners, and only set this to true if it does.\n   */\n  passive?: boolean;\n}\n\nconst defaultThrottleDelay = 500;\n\n/*\n * An interrupt source on an EventTarget object, such as a Window or HTMLElement.\n */\nexport class EventTargetInterruptSource extends InterruptSource {\n  private eventSrc: Observable<any>;\n  private eventSubscription: Subscription = new Subscription();\n  protected throttleDelay: number;\n  protected passive: boolean;\n\n  constructor(\n    protected target: any,\n    protected events: string,\n    options?: number | EventTargetInterruptOptions\n  ) {\n    super(null, null);\n\n    if (typeof options === 'number') {\n      options = { throttleDelay: options, passive: false };\n    }\n\n    options = options || {\n      throttleDelay: defaultThrottleDelay,\n      passive: false\n    };\n\n    if (options.throttleDelay === undefined || options.throttleDelay === null) {\n      options.throttleDelay = defaultThrottleDelay;\n    }\n\n    this.throttleDelay = options.throttleDelay;\n    this.passive = !!options.passive;\n\n    const opts = this.passive ? { passive: true } : null;\n    const fromEvents = events\n      .split(' ')\n      .map(eventName => fromEvent<any>(target, eventName, opts));\n    this.eventSrc = merge(...fromEvents);\n    this.eventSrc = this.eventSrc.pipe(\n      filter(innerArgs => !this.filterEvent(innerArgs))\n    );\n    if (this.throttleDelay > 0) {\n      this.eventSrc = this.eventSrc.pipe(throttleTime(this.throttleDelay));\n    }\n\n    const handler = (innerArgs: any) =>\n      this.onInterrupt.emit(new InterruptArgs(this, innerArgs));\n\n    this.attachFn = () =>\n      (this.eventSubscription = this.eventSrc.subscribe(handler));\n\n    this.detachFn = () => this.eventSubscription.unsubscribe();\n  }\n\n  /*\n   * Checks to see if the event should be filtered. Always returns false unless overriden.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n  protected filterEvent(event: any): boolean {\n    return false;\n  }\n\n  /**\n   * Returns the current options being used.\n   * @return The current option values.\n   */\n  get options(): EventTargetInterruptOptions {\n    return { throttleDelay: this.throttleDelay, passive: this.passive };\n  }\n}\n","import {\n  EventTargetInterruptOptions,\n  EventTargetInterruptSource\n} from './eventtargetinterruptsource';\n\n/*\n * An interrupt source that uses events on the document element (html tag).\n */\nexport class DocumentInterruptSource extends EventTargetInterruptSource {\n  constructor(events: string, options?: number | EventTargetInterruptOptions) {\n    super(document.documentElement, events, options);\n  }\n\n  /*\n   * Checks to see if the event should be filtered.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n  filterEvent(event: any): boolean {\n    // some browser bad input hacks\n    if (\n      event.type === 'mousemove' &&\n      // fix for Chrome destop notifications\n      ((event.originalEvent &&\n        event.originalEvent.movementX === 0 &&\n        event.originalEvent.movementY === 0) ||\n        // fix for webkit fake mousemove\n        ((event.movementX !== void 0 && !event.movementX) || !event.movementY))\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n}\n","import {\n  EventTargetInterruptOptions,\n  EventTargetInterruptSource\n} from './eventtargetinterruptsource';\n\n/*\n * An interrupt source on the Window object.\n */\nexport class WindowInterruptSource extends EventTargetInterruptSource {\n  constructor(events: string, options?: number | EventTargetInterruptOptions) {\n    super(window, events, options);\n  }\n}\n","import { WindowInterruptSource } from './windowinterruptsource';\n\n/*\n * An interrupt source on the storage event of Window.\n */\nexport class StorageInterruptSource extends WindowInterruptSource {\n  constructor(throttleDelay = 500) {\n    super('storage', throttleDelay);\n  }\n\n  /*\n   * Checks to see if the event should be filtered.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n  filterEvent(event: StorageEvent): boolean {\n    if (\n      event.key &&\n      event.key.indexOf('ng2Idle.') >= 0 &&\n      event.key.indexOf('.expiry') >= 0\n    ) {\n      return false;\n    }\n    return true;\n  }\n}\n","import { IdleExpiry } from './idleexpiry';\n\n/*\n * Represents a simple in-memory store of expiry values.\n * @extends IdleExpiry\n */\nexport class SimpleExpiry extends IdleExpiry {\n  private lastValue: Date = null;\n\n  constructor() {\n    super();\n  }\n\n  /*\n   * Gets or sets the last expiry date.\n   * @param value - The expiry value to set; omit to only return the value.\n   * @return The current expiry value.\n   */\n  last(value?: Date): Date {\n    if (value !== void 0) {\n      this.lastValue = value;\n    }\n\n    return this.lastValue;\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\n\nimport { Idle } from './idle';\nimport { IdleExpiry } from './idleexpiry';\nimport { LocalStorageExpiry } from './localstorageexpiry';\nimport { LocalStorage } from './localstorage';\n\n@NgModule({\n  providers: [LocalStorage]\n})\nexport class NgIdleModule {\n  static forRoot(): ModuleWithProviders<NgIdleModule> {\n    return {\n      ngModule: NgIdleModule,\n      providers: [\n        LocalStorageExpiry,\n        { provide: IdleExpiry, useExisting: LocalStorageExpiry },\n        Idle\n      ]\n    };\n  }\n}\n","import { DocumentInterruptSource } from './documentinterruptsource';\nimport { EventTargetInterruptOptions } from './eventtargetinterruptsource';\nimport { StorageInterruptSource } from './storageinterruptsource';\n\nexport function createDefaultInterruptSources(\n  options?: EventTargetInterruptOptions\n) {\n  return [\n    new DocumentInterruptSource(\n      'mousemove keydown DOMMouseScroll mousewheel mousedown touchstart touchmove scroll',\n      options\n    ),\n    new StorageInterruptSource()\n  ];\n}\n\nexport const DEFAULT_INTERRUPTSOURCES: any[] = createDefaultInterruptSources();\n"]}